// MACROS
#w a z
#W A Z
#o 0 7
#d 0 9
#h a f
#H A F
#n #10 // 10 is \n
// Macros name must consist of 1 char A-Z or a-z

// ADDRESS LAYOUT

// 0 - 999 reserved
// 1000 - 1999 - errors

// 2000 - 2099 constants
// 2100 - 2999 temp for constants

// 3000 - 3099 operators
0 { 3000
0 } 3001
0 ( 3004
0 ) 3005
0 [ 3006
0 ] 3007
0 . 3008
0 ! 3014
0 ~ 3015
0 * 3018
0 / 3019
0 % 3020
0 + 3021
3021 + 3002 // ++
0 - 3022
3022 - 3003 // --
3022 > 3009 // ->
0 < 3025
3025 = 3026 // <=
3025 < 3023 // <<
0 > 3027
3027 = 3028 // >=
3027 > 3024 // >>
3014 = 3033 // !=
0 & 3034
0 ^ 3035
0 | 3036
3034 & 3035 // &&
3036 | 3038 // ||
0 ? 3039
0 : 3040
0 = 3041
3041 = 3029 // ==
0 , 3042

// 3100 - 3999 temp for operators

// 4000 - 4999 keywords
// 5000 - 5999 variable names
// 6000 - 8999 temp for keywords and variables

// 9000 - 9999 common uses 

// Start parsing lexeme from state 0 and jump into your state
// If no matches from current state is found, 
// lexeme will be saved with code of current state 
// and new state is set to 0 

// Use the following format: 
// CUR_STATE MATCH_PATTERN NEW_STATE
// For example: 
// 0 xyz 4500
// 0 i 4501 // i..
// 4000 #wWd 4500 // if..
// 4500 #wWd 4500
// 4501 f 4000 // if or if..
// 4501 #wWd 4500 // iz..

// All instructions must be sorted by CUR_STATE

// HOW TO USE CHAR PATTERNS
// AB - symbol A or symbol B
// # - symbol '#'
// #AB - any symbol from (macro A + macro B)
// ALL CHAR PATTERNS MUST BE PLACED AFTER ALL SIMPLE CHAR SEQUENCES OF THIS STATE
// For example, this is not allowed: 
//     0 #wW 1
//     0 abc 2

// LEXEME PARSING INSTRUCTIONS:
